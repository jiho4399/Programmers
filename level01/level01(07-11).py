# -*- coding: utf-8 -*-
"""level01(07-).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/158BTZ9veJV0lk42OZCdG-BoC833GAW8Y

# 7.평균 구하기
"""

def solution(arr):
  return sum([i for i in arr]) / len(arr)

# 메모장
arr = [1,2,3,4]

lst = []

for i in arr:
  lst.append(i)
  a = sum(lst)
print(a)

solution([1,10,2,3,4])

"""# 8.콜라츠 추측"""

def solution(n):
  count = 0

  if n == 1: 
    return 0

  while True:
    if n % 2 == 0:
      n = n/2
      count += 1
    else:
      n = n*3+1
      count += 1

    if n == 1:
      return count
    elif count == 500:
      return -1
  return count



# 메모장

count = 0
n = 6

# if n == 1: 
#   return 1

while True:
  if n % 2 == 0:
    n = n/2
    count += 1
  else:
    n = n*3+1
    count += 1
  
  if n == 1:
    return count
  elif count == 500:
    return -1

count

solution(626331)

"""# 9.최대공약수와 최소공배수"""

# 안됨
def solution(n, m):
  k = m % n
  if k != 0:
    return [1, n*m]
  
  else:
    return [n, m]

solution(7, 35)

# 유클리드 호제법
# n과 m이 있을 때 n < m 이라고 가정
# m/n 을 하고 그 나머지를 n이라고 두고 나누기에서 n역할을 한 수가 m이 됨
################
# 예) n = 35, m = 60 일 때 m/n 을 하면 나머지 = 25.
# 25가 다시 n이 되고 m = 35
# 또 m/n을 하면 나머지 = 10.  n = 10, m = 25 ..... 반복!!!
################
# 나머지가 0이 될 때 까지 반복하고 나머지가 0일 경우 그 몫이 최대공약수가 됨
# 최초의 n과 m을 곱한 수/최소공약수 = 최소공배수

def solution(n, m):
  if n < m:
    num = n*m
    while n != 0:
      (n, m) = (m%n, n)
    return [m, int(num/m)]
    
  elif n > m:
    num = n*m
    (n, m) = (m, n)
    while n != 0:
      (n, m) = (m%n, n)
    return [m, int(num/m)]

solution(35, 60)

solution(60, 35)

"""# 10. 제일 작은 수 제거하기"""

# arr에서 가장 작은 수를 제거한 배열을 리턴하는 함수
# 빈 배열일 경우 -1 리턴
# 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j]

def solution(arr):
  if len(arr) == 1:
    arr = []
    arr.append(-1)

  else:
    arr.remove(min(arr))
  return arr


# 이것도 됨!!!
# 비어있는 경우 자동을 -1 부여하는 듯
def solution(arr):
    arr.remove(min(arr))
    return arr

arr = [4, 3, 2, 1, 1]
arr = [10]

# lst = []

# for i in arr:
#   if i != min(arr):
#     lst.append(i)

[i for i in arr if i != min(arr)]
[i for i in arr if i > min(arr)]

solution([1])

"""# 11.정수 제곱근 판별"""

# 임의의 양의 정수 n
# n이 어떤 양의 정수 x의 제곱인지 아닌지 판단

# n이 양의 정수 x의 제곱이라면 x+1의 제곱을 리턴
# 아니라면 -1을 리턴하는 함수

def solution(n):
  x = n**(1/2)
  if n % x == 0:
    return int((x+1)**2)

  else:
    return -1

n = 121
x = n**(1/2)
if n % x == 0:

  print((x+1)**2)

else:
  print(-1)

solution(3)

